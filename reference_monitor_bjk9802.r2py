"""
This security layer handles the Versioned and Immutable functionality

Note:
    This security layer uses encasementlib.r2py, restrictions.default, repy.py and Python
    Also you need to give it an application to run.
    python repy.py restrictions.default encasementlib.r2py [security_layer].r2py [attack_program].r2py 
    
"""
TYPE = "type"
ARGS = "args"
RETURN = "return"
EXCP = "exceptions"
TARGET = "target"
FUNC = "func"
OBJC = "objc"

import random

# Global bookkeeping
OPEN_FILES = {}
VERSION_METADATA = {}
GLOBAL_LOCK = createlock()
COPY_CHUNK_SIZE = 8192

# --- Exceptions ---
class RepyArgumentError(Exception): pass
class FileInUseError(Exception): pass
class FileNotFoundError(Exception): pass


# --- Internal helpers ---
def _parse_version_filename(filename):
    if not filename or ".v" not in filename:
        return None
    parts = filename.rsplit(".v", 1)
    if len(parts) == 2 and parts[1].isdigit():
        base, ver = parts[0], int(parts[1])
        if ver >= 1:
            return (base, ver)
    return None

def _get_version_filename(base, ver):
    return f"{base}.v{ver}"

def _file_exists_atomic(filename):
    try:
        f = openfile(filename, False)
        f.close()
        return True
    except:
        return False

def _scan_existing_versions(base_filename):
    """Scan for existing versions, return dict and max version number."""
    versions = {}
    maxv = 0
    # .v1, .v2, ...
    v = 1
    while True:
        name = _get_version_filename(base_filename, v)
        if _file_exists_atomic(name):
            versions[v] = True
            maxv = v
            v += 1
        else:
            break
    return versions, maxv

def _efficient_file_copy(src, dst):
    try:
        sf = openfile(src, False)
        df = openfile(dst, True)
        offset = 0
        while True:
            chunk = sf.readat(COPY_CHUNK_SIZE, offset)
            if not chunk:
                break
            df.writeat(chunk, offset)
            offset += len(chunk)
        sf.close()
        df.close()
    except Exception as e:
        try:
            removefile(dst)
        except:
            pass
        raise e


# --- Main object ---
class SecureVMFile:
    def __init__(self, filename, create):
        self.filename = filename
        self.base = None
        self.version = None
        self.latest = False
        self.closed = False
        self._actual = None
        self.VMfile = None

        GLOBAL_LOCK.acquire(True)
        try:
            self._secure_open(filename, create)
        finally:
            GLOBAL_LOCK.release()

    def _secure_open(self, filename, create):
        verinfo = _parse_version_filename(filename)

        # --- If explicit version requested ---
        if verinfo:
            base, v = verinfo
            if create:
                raise RepyArgumentError("Cannot explicitly create versioned file")

            if base not in VERSION_METADATA:
                vers, maxv = _scan_existing_versions(base)
                VERSION_METADATA[base] = {"versions": vers, "max": maxv}

            meta = VERSION_METADATA[base]
            if v not in meta["versions"]:
                raise FileNotFoundError("Requested version not found")

            vname = _get_version_filename(base, v)
            if vname in OPEN_FILES:
                raise FileInUseError("Version already open")

            self.VMfile = openfile(vname, False)
            self._actual = vname
            self.base = base
            self.version = v
            self.latest = (v == meta["max"])
            OPEN_FILES[vname] = True
            return

        # --- Base (unversioned) access ---
        self.base = filename
        if filename not in VERSION_METADATA:
            vers, maxv = _scan_existing_versions(filename)
            VERSION_METADATA[filename] = {"versions": vers, "max": maxv}

        meta = VERSION_METADATA[filename]
        has_versions = meta["max"] > 0
        base_exists = _file_exists_atomic(filename)

        if self._is_file_or_version_open(filename):
            raise FileInUseError("File or one of its versions already open")

        # --- CREATE path ---
        if create:
            if not base_exists and not has_versions:
                # First version ever
                self.VMfile = openfile(filename, True)
                self._actual = filename
                self.version = 1
                self.latest = True
                meta["versions"][1] = True
                meta["max"] = 1
                OPEN_FILES[filename] = True
            else:
                current_max = meta["max"]
                src = (
                    filename if current_max == 0
                    else _get_version_filename(filename, current_max)
                )
                newv = current_max + 1
                newname = _get_version_filename(filename, newv)

                if _file_exists_atomic(newname):
                    # Safety: version number collision â€” skip to next
                    newv += 1
                    newname = _get_version_filename(filename, newv)

                # Atomic create via random temp + rename
                tmpname = f"{filename}.tmp{random.randint(10000,99999)}"
                _efficient_file_copy(src, tmpname)
                try:
                    renamefile(tmpname, newname)  # atomic rename (if available)
                except:
                    # fallback: copy directly
                    _efficient_file_copy(src, newname)
                    try:
                        removefile(tmpname)
                    except:
                        pass

                meta["versions"][newv] = True
                meta["max"] = newv
                self.VMfile = openfile(newname, True)
                self._actual = newname
                self.version = newv
                self.latest = True
                OPEN_FILES[newname] = True
        else:
            # --- OPEN path ---
            if not base_exists and not has_versions:
                raise FileNotFoundError("File does not exist")

            if has_versions:
                v = meta["max"]
                latest = _get_version_filename(filename, v)
                self.VMfile = openfile(latest, False)
                self._actual = latest
                self.version = v
                self.latest = True
            else:
                self.VMfile = openfile(filename, False)
                self._actual = filename
                self.version = 1
                self.latest = True

            OPEN_FILES[self._actual] = True

    def _is_file_or_version_open(self, base):
        if base in OPEN_FILES:
            return True
        if base in VERSION_METADATA:
            for v in VERSION_METADATA[base]["versions"]:
                if _get_version_filename(base, v) in OPEN_FILES:
                    return True
        return False

    def readat(self, n, off):
        if self.closed:
            raise FileInUseError("File closed")
        return self.VMfile.readat(n, off)

    def writeat(self, data, off):
        if self.closed:
            raise FileInUseError("File closed")
        if not self.latest:
            raise FileInUseError("Cannot write to older version")
        return self.VMfile.writeat(data, off)

    def close(self):
        if self.closed:
            return
        GLOBAL_LOCK.acquire(True)
        try:
            if self._actual in OPEN_FILES:
                del OPEN_FILES[self._actual]
        finally:
            GLOBAL_LOCK.release()
        self.closed = True
        self.VMfile.close()


# --- Public API bindings ---
def LPopenfile(fname, create):
    return SecureVMFile(fname, create)

def LPremovefile(fname):
    raise RepyArgumentError("Deletion forbidden")

def LPlistfiles():
    GLOBAL_LOCK.acquire(True)
    try:
        all_files = listfiles()
        return [f for f in all_files if not _parse_version_filename(f)]
    finally:
        GLOBAL_LOCK.release()


# --- Initialize metadata cache on load ---
def _init_global_state():
    GLOBAL_LOCK.acquire(True)
    try:
        allf = listfiles()
        bases = set()
        for f in allf:
            info = _parse_version_filename(f)
            if info:
                bases.add(info[0])
            else:
                bases.add(f)
        for b in bases:
            if b not in VERSION_METADATA:
                vmap, mv = _scan_existing_versions(b)
                VERSION_METADATA[b] = {"versions": vmap, "max": mv}
    finally:
        GLOBAL_LOCK.release()

_init_global_state()


# The code below sets up type checking and variable hiding for you.
# You should not change anything below this point.
sec_file_def = {
    "obj-type": VMFile,
    "name": "VMFile",
    "writeat": {"type": "func", "args": (str, (int, long)), "exceptions": Exception, "return": (int, type(None)), "target": VMFile.writeat},
    "readat": {"type": "func", "args": ((int, long, type(None)), (int, long)), "exceptions": Exception, "return": str, "target": VMFile.readat},
    "close": {"type": "func", "args": None, "exceptions": Exception, "return": (bool, type(None)), "target": VMFile.close}
}

CHILD_CONTEXT_DEF["openfile"] = {
    TYPE: OBJC,
    ARGS: (str, bool),
    EXCP: Exception,
    RETURN: sec_file_def,
    TARGET: LPopenfile
}

CHILD_CONTEXT_DEF["removefile"] = {
    TYPE: FUNC,
    ARGS: (str,),
    EXCP: Exception,
    RETURN: type(None),
    TARGET: LPremovefile
}

CHILD_CONTEXT_DEF["listfiles"] = {
    TYPE: FUNC,
    ARGS: None,
    EXCP: Exception,
    RETURN: list,
    TARGET: LPlistfiles
}

# Execute the user code
secure_dispatch_module()